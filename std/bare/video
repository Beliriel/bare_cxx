//-*-coding: mule-utf-8-unix; fill-column: 59; mode:c++ -*-
/** 
 * @file
 *
 * This file is a part of Bare Metal OS C++ library.
 *
 * @author Sergei Lodyagin <serg@kogorta.dp.ua>
 * @copyright (C) 2013 Cohors LLC
 *
 */

#ifndef _BARE_VIDEO_HEADER_
#define _BARE_VIDEO_HEADER_

#include <iterator>
#include <cstddef>
#include <streambuf>

namespace bare { 

#ifdef LINUX

inline void b_output_chars
  (const char *str, unsigned long nbr)
{
  register int syscall asm ("rax") = 4; //sys_write
  register int file asm ("rbx") = 1; // stdout
  register const char* buf asm ("rcx") = str;
  register unsigned long n asm ("rdx") = nbr;
  asm ("int $0x80" 
       : : "r" (file), "r" (buf), "r" (n), "r" (syscall)
       );
}

#else

inline void b_output_chars
  (const char *str, unsigned long nbr)
{
  asm volatile ("call *0x00100018" : : "S"(str), "c"(nbr));
}

#endif

namespace video {

#if 0
/**
 * The video::terminal::iterator implementation. It
 * implements an OutputIterator concept
 * over the BareMetal OS screen output syscalls. It is very
 * similar to std::ostream_iterator but works with the
 * screen directly without buffering.
 *
 * @author Sergei Lodyagin
 */
template<class CharT>
class _terminal_iterator 
  : public std::iterator 
      <std::output_iterator_tag, void, void, void, void>
{
  friend terminal;
public:
  //typedef iterator::iterator_category iterator_category;
  typedef CharT char_type;

  reference operator * () noexcept
  {
    return a_begin[idx];
  }

  const_reference operator * () const noexcept
  {
    return a_begin[idx];
  }

  //! A "cycled" implementation. carry is incremented
  //! witch each overlap.
  _array_iterator& operator ++ () noexcept
  {
    if (__builtin_expect(idx++ >= N, 0))
    {
      idx = 0;
      static_assert(N < UINT64_MAX/4, "array: too big");
      carry += N;
    }
    return *this;
  }

  _array_iterator operator ++ (int) noexcept
  {
    _array_iterator copy(*this);
    ++(*this);
    return copy;
  }

  _array_iterator& operator += (difference_type n) noexcept
  {
    if (__builtin_expect((idx + n) >= N, 0))
    {
      idx += n % N;
      carry += n - n % N;
    }
    return *this;
  }

  _array_iterator operator + (difference_type n) const noexcept
  {
    _array_iterator i(*this);
    i += n;
    return i;
  }

  //! A "cycled" implementation. carry is incremented
  //! witch each overlap.
  _array_iterator& operator -- () noexcept
  {
    if (__builtin_expect(idx-- == 0, 0))
    {
      idx = N - 1;
      static_assert(N < UINT64_MAX/4, "array: too big");
      carry -= N;
    }
    return *this;
  }

  _array_iterator& operator -= (difference_type n) noexcept
  {
    return operator+=(-n);
  }

  _array_iterator operator - (difference_type n) const noexcept
  {
    _array_iterator i(*this);
    i -= n;
    return i;
  }

  difference_type operator - (const _array_iterator b) const 
  noexcept
  {
    return virtual_ptr() - b.virtual_ptr();
  }

  reference operator [] (difference_type n) noexcept
  {
    return *(*this + n);
  }

  const_reference operator [] (difference_type n) 
    const noexcept
  {
    return const_cast<_array_iterator*>(this)->operator[](n);
  }

private:
  _array_iterator(T a_ptr[], size_type the_idx) noexcept 
    : a_begin(a_ptr),
      carry(0)
  {
    static_assert(N > 0, "array: wrong specialization");
    *this += the_idx;
  }

  //! construct a begin iterator
  _array_iterator(T a_ptr[], begin_t) noexcept 
    : a_begin(a_ptr),
      idx(0),
      carry(0)
  {
  }

  //! construct a past-the-end iterator
  _array_iterator(T a_ptr[], end_t) noexcept 
    : a_begin(a_ptr),
      idx(0),
      carry(N)
  {
  }

  const T* virtual_ptr() const noexcept
  {
    return a_begin + idx + carry;
  }

  // TODO cache-line alignment
  T* a_begin;
  size_type idx;
  difference_type carry;
};

// TODO check copy-ellision
template<class T, _STD::size_t N>
inline _array_iterator<T,N> operator + 
  (typename _array_iterator<T,N>::difference_type n, 
   _array_iterator<T,N> i)
     noexcept
{
  return i + n;
}

// TODO check copy-ellision
template<class T, _STD::size_t N>
inline _array_iterator<T,N> operator - 
  (typename _array_iterator<T,N>::difference_type n, 
   _array_iterator<T,N> i) 
     noexcept
{
  return i - n;
}

#endif

/**
  * Output to a terminal.
  */
template <
  class CharT,
  class Traits = std::char_traits<CharT>
>
class basic_streambuf
  : public std::basic_streambuf<CharT, Traits>
{
  typedef typename 
    std::basic_streambuf<CharT, Traits>::char_type 
    char_type;

protected:
  std::streamsize xsputn(
	 const char_type* s, 
	 std::streamsize count
  ) noexcept override
  {
#ifndef LINUX
    b_output_chars(s, count);
#else
    // *s can't be on stack
	 for (auto i = count; i > 0; i--)
	 {
		ch_ = *s++;
		b_output_chars(&ch_, 1);
	 }
#endif
    return count;
  }

private:
#ifdef LINUX
  static char ch_;
#endif
};

#ifdef LINUX
template <class CharT, class Traits>
char basic_streambuf<CharT, Traits>::ch_;
#endif

} // video
} // bare

#endif
