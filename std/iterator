// -*-coding: mule-utf-8-unix; fill-column: 59 -*-
/** 
 * @file
 *
 * This file is a part of Bare C++ library. Bare C++
 * library is a standard library specially designed for
 * systems without memory protection like exokernel
 * operating systems.
 *
 * @author Sergei Lodyagin <serg@kogorta.dp.ua>
 * @copyright (C) 2013 Cohors LLC
 *
 */

#ifndef _ITERATOR_HEADER_
#define _ITERATOR_HEADER_

namespace _STD {

// iterator categories

struct input_iterator_tag {};

struct output_iterator_tag {};

struct forward_iterator_tag 
  : public input_iterator_tag {};

struct bidirectional_iterator_tag 
  : public forward_iterator_tag {};

struct random_access_iterator_tag 
  : public bidirectional_iterator_tag {};

// the iterator base class

template <
  class Category,
  class T,
  class Distance = _STD::ptrdiff_t,
  class Pointer = T*,
  class Reference = T&
> 
struct iterator
{
  typedef T value_type;
  typedef Distance difference_type;
  typedef Pointer pointer;
  typedef Reference reference;
  typedef Category iterator_category;
};

template<class Iterator>
struct iterator_traits
{
  typedef Iterator::difference_type difference_type;
  typedef Iterator::value_type difference_type;
  typedef Iterator::pointer pointer;
  typedef Iterator::reference reference;
  typedef Iterator::iterator_category iterator_category;
};

template<class Iterator>
class reverse_iterator 
  : public iterator <
      typename iterator_traits<Iterator>::iterator_category,
      typename iterator_traits<Iterator>::value_type,
      typename iterator_traits<Iterator>::difference_type,
      typename iterator_traits<Iterator>::pointer,
      typename iterator_traits<Iterator>::reference 
    >
{
  typedef iterator_traits<Iterator> TR;
public:
  typedef Iterator iterator_type;
  typedef typename TR::difference_type difference_type;
  typedef typename TR::pointer pointer;
  typedef typename TR::reference reference;

  explicit reverse_iterator(Iterator x) 
    : it(x) 
  {}

  template<class U>
  reverse_iterator(const reverse_iterator<U>& other)
    : it(other.base())
  {}

  template<class U>
  reverse_iterator& operator = 
    (const reverse_iterator<U>& other)
  {
    it = other.base();
  }

  Iterator base() const
  {
    return it;
  }

  reverse_iterator operator * () const
  {
    Iterator copy(it);
    return *--copy;
  }

  pointer operator -> () const
  {
    return &(operator*());
  }

  reverse_iterator& operator ++ ()
  {
    --it;
    return *this;
  }

  reference operator [] (difference_type n) const
  {
    ?
  }

protected:
  Iterator it;
};

template<class It>
reverse_iterator<It> operator ++ 
  (reverse_iterator<It>& ri, int)
{
  reverse_iterator copy(ri);
  --ri;
  return copy;
}

template<class It>
reverse_iterator<It> operator ++ 
  (reverse_iterator<It>&& ri, int)
{
  return reversible_iterator
    (It::operator--(std::move(ri.it), 0));
}

template<class It>
reverse_iterator<It> operator --
  (reverse_iterator<It>& ri, int)
{
  reverse_iterator copy(ri);
  ++ri;
  return copy;
}

template<class It>
reverse_iterator<It> operator --
  (reverse_iterator<It>&& ri, int)
{
  return reversible_iterator
    (It::operator++(std::move(ri.it), 0));
}

}

#endif
