// -*-coding: mule-utf-8-unix; fill-column: 58 -*-
/** 
 * @file
 *
 * This file is a part of Bare C++ library. Bare C++ library is a standard
 * library specially designed for systems without memory protection like
 * exokernel operating systems.
 *
 * @author Sergei Lodyagin <serg@kogorta.dp.ua>
 * @copyright (C) 2013 Cohors LLC
 *
 */

#ifndef _ARRAY_HEADER_
#define _ARRAY_HEADER_

//#include <type_traits>

namespace std {

/**
 * The std::array implementation.
 * It is "cycled", iterator++ at the last cell jumps to
 * start. As a result a difference between two iterators
 * count overlaps. A difference between two iterators for
 * different arrays of the same type is +-INT32_MAX
 * depending of memory order of the arrays.
 *
 * @author Sergei Lodyagin
 */
template<class T, std::size_t N>
class array
{
  T arr[N];
  typedef uint_fast32_t index_type;
  typedef uint32_t smallest_index_type;
  typedef int8_t carry_type;
public:
  constexpr static alien_array_positive_distance = INT64_MAX;
  constexpr static alien_array_negative_distance = INT64_MIN;

  // <NB> no UINT_FAST32_MAX, to allow a distance
  // calculation without overflow
  static_assert(N <= UINT32_MAX,
                "array: the size is too big");

  static_assert
    (log2x<8 * (sizeof(smallest_index_type) 
                + sizeof(carry_type))>
     < min(alien_array_positive_distance,
           - alien_array_negative_distance),
     "array: unable to proper calculate distances");

  typedef T value_type;
//  static_assert(is_destructible<T>, 
//               "array::value_type must be Destructible");

  class reference
  {
  public:
    T* operator & () noexcept = delete;
  };

  typedef const reference const_reference;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;

  // TODO add const_assert-s on
  // difference_type/size_type/alien distance relations

  // TODO size_type as smallest_index_type?

  class iterator
  {
  public:
    bool operator == (const iterator& b) const noexcept
    { 
      return idx == b.idx 
        && __builtin_expect(carry == b.carry, 1)
        && __builtin_expect(a == b.a, 1);
    }
  
    bool operator != (const iterator& b) const noexcept
    {
      return !operator==(b);
    }

    bool operator < (const iterator& b) const noexcept
    {
      return *this - b < 0;
    }

    bool operator > (const iterator& b) const noexcept
    {
      return *this - b > 0;
    }

    bool operator <= (const iterator& b) const noexcept
    {
      return *this - b <= 0;
    }

    bool operator >= (const iterator& b) const noexcept
    {
      return *this - b >= 0;
    }

    reference operator * () noexcept
    {
      return a[idx];
    }

    const_reference operator * () const noexcept
    {
      return a[idx];
    }

    //! A "cycled" implementation. carry is incremented
    //! witch each overlap.
    iterator& operator ++ () noexcept
    {
      if (__builtin_expect(++idx >= N, 0))
        ++carry;
      return *this;
    }

    //! A "cycled" implementation. carry is incremented
    //! witch each overlap.
    iterator operator ++ () noexcept
    {
      iterator copy(*this);
      ++(*this);
      return copy;
    }

    difference_type operator - (const iterator& b) const 
      noexcept
    {
      if (__builtin_expect(a == b.a, 1))
      {
        const difference_type diff = ptr() - b.ptr();
        const int16_t overlaps = carry - b.carry;
        if (__builtin_expect(overlaps == 0, 1))
          return diff;
        else
          return diff + N * (carry - b.carry);
      }
      else if (a < b.a) 
        return alien_array_negative_distance;
      else
        return alien_array_positive_distance;
    }

  private:
    iterator(T a_ptr[]) noexcept : a(a_ptr) {}

    const T* ptr() const noexcept
    {
      return a + idx;
    }

    T * const a;
    uint_fast32_t idx = 0;
    int8_t carry;
  };

  typedef const iterator const_iterator;
};

}

#endif
