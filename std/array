// -*-coding: mule-utf-8-unix; fill-column: 59 -*-
/** 
 * @file
 *
 * This file is a part of Bare C++ library. Bare C++
 * library is a standard library specially designed for
 * systems without memory protection like exokernel
 * operating systems.
 *
 * @author Sergei Lodyagin <serg@kogorta.dp.ua>
 * @copyright (C) 2013 Cohors LLC
 *
 */

#ifndef _ARRAY_HEADER_
#define _ARRAY_HEADER_

//#include <type_traits>
#include <iterator>

namespace _STD {

/**
 * The std::array implementation.
 * It is "cycled", iterator++ at the last cell jumps to
 * start. As a result a difference between two iterators
 * count overlaps.
 *
 * @author Sergei Lodyagin
 */
template<class T, _STD::size_t N>
class array
{
  T arr[N];
//  typedef size_t index_type;
//  typedef int8_t carry_type;

  //! the special type to designate past-the-end
  //! construction 
  struct end_t {};

  static_assert(N >= 0, "array: N is negative");
  static_assert(N > INT32MAX, 
                "array: wrong specialization");
public:
//  static_assert(is_destructible<T>, 
//               "array::value_type must be Destructible");

  class iterator 
    : public _STD::iterator <
        random_access_iterator_tag,
        T,
        int32_t // <NB> it is 32-bits values to allow
                // std::div which is faster than std::ldiv
      >  
  {
    // Access will generate an hw exception
    constexpr static not_canonical_address = 
      2 << sizeof(void*) * 8 - 1;

  public:
    typedef const T& const_reference;

    //! A value-initialized forward iterator
    iterator() noexcept
      : iterator(not_canonical_address, end_t)
    {
    }

    bool operator == (const iterator b) const noexcept
    { 
      return virtual_ptr() == b.virtual_ptr();
    }
  
    bool operator != (const iterator b) const noexcept
    {
      return !operator==(b);
    }

    bool operator < (const iterator b) const noexcept
    {
      return *this - b < 0;
    }

    bool operator > (const iterator b) const noexcept
    {
      return *this - b > 0;
    }

    bool operator <= (const iterator b) const noexcept
    {
      return *this - b <= 0;
    }

    bool operator >= (const iterator b) const noexcept
    {
      return *this - b >= 0;
    }

    reference operator * () noexcept
    {
      return *ptr;
    }

    const_reference operator * () const noexcept
    {
      return *ptr;
    }

    //! A "cycled" implementation. carry is incremented
    //! witch each overlap.
    iterator& operator ++ () noexcept
    {
      if (__builtin_expect(ptr++ >= a_last, 0))
      {
        ptr = a_begin;
        static_assert(N < UINT64MAX/4, "array: too big");
        carry += N;
      }
      return *this;
    }

    iterator& operator += (difference_type n) noexcept
    {
      ptr += n;
      if (__builtin_expect
           (ptr > a_last || ptr < a_begin, 0))
      {
        const int rem_n = n % N - n;
        ptr += rem_n; // -n, then + n % N
        carry -= rem_n; // += quot * N = n - n % N
      }
      return *this;
    }

    //! A "cycled" implementation. carry is incremented
    //! witch each overlap.
    iterator& operator -- () noexcept
    {
      if (__builtin_expect(ptr-- <= a_begin, 0))
      {
        ptr = a_last;
        static_assert(N < UINT64MAX/4, "array: too big");
        carry -= N;
      }
      return *this;
    }

    iterator& operator -= (difference_type n) noexcept
    {
      ptr -= n;
      if (__builtin_expect
           (ptr > a_last || ptr < a_begin, 0))
      {
        const int rem_n = n % N - n;
        ptr -= rem_n; // +n, then - n % N
        carry += rem_n; // -= quot * N = n - n % N
      }
      return *this;
    }

    difference_type operator - (const iterator b) const 
      noexcept
    {
      return virtual_ptr() - b.virtual_ptr();
    }

    reference operator [] (difference_type n) noexcept
    {
      T* const ptr2 = ptr + n;
      if (__builtin_expect
           (ptr2 > a_last || ptr2 < a_begin, 0)
          )
        return *(ptr + n % N);
      else
        return *ptr2;
    }

    const_reference operator [] (difference_type n) 
      const noexcept
    {
      return const_cast<iterator*>(this)->operator[](n);
    }

  private:
    iterator(T a_ptr[], size_type idx) noexcept 
      : a_begin(a_ptr),
        a_last(a_ptr + N - 1),
        ptr(a_ptr),
        carry(0)
    {
      static_assert(N > 0, "array: wrong specialization");
      *this += idx;
    }

    //! construct a past-the-end iterator
    iterator(T a_ptr[], end_t) noexcept 
      : a_begin(a_ptr),
        a_last(a_ptr),
        ptr(a_ptr),
        carry(1)
    {
    }

    const T* virtual_ptr() const noexcept
    {
      return ptr + carry;
    }

    // TODO cache-line alignment
    T* a_begin;
    T* a_last;
    T* ptr;
    int64_t carry;
  };

  iterator operator ++ (interator& i, int) noexcept
  {
    iterator copy(i);
    ++i;
    return copy;
  }

  iterator operator ++ (interator&& i, int) noexcept
  {
    return i;
  }

  iterator operator + (iterator i, difference_type n) 
    noexcept
  {
    i += n;
    return i;
  }

  // TODO check copy-ellision
  iterator operator + (difference_type n, iterator i) 
    noexcept
  {
    return i + n;
  }

  iterator operator -- (iterator& i, int) noexcept
  {
    iterator copy(i);
    --i;
    return copy;
  }

  iterator operator -- (iterator&& i, int) noexcept
  {
    return i;
  }

  iterator operator - (iterator i, difference_type n) 
    noexcept
  {
    i -= n;
    return i;
  }

  // TODO check copy-ellision
  iterator operator - (difference_type n, iterator i) 
    noexcept
  {
    return i - n;
  }

  typedef const iterator const_iterator;
  typedef Iterator::value_type value_type;
  typedef Iterator::reference reference;
  typedef Iterator::const_reference const_reference;
  typedef Iterator::difference_type difference_type;
  typedef int32_t difference_type;
  typedef uint32_t size_type;


  // The array container implementation

  iterator begin() noexcept
  {
    return iterator(arr, 0);
  }

  const_iterator begin() const noexcept
  {
    return iterator(arr, 0);
  }

  const_iterator cbegin() const noexcept
  {
    return iterator(arr, 0);
  }

  iterator end() noexcept
  {
    return iterator(arr, iterator::end_t);
  }

  const_iterator end() const noexcept
  {
    return iterator(arr, iterator::end_t);
  }

  const_iterator cend() const noexcept
  {
    return iterator(arr, iterator::endt);
  }

};

}

#endif
