// -*-coding: mule-utf-8-unix; fill-column: 58 -*-
/** 
 * @file
 *
 * This file is a part of Bare C++ library. Bare C++
 * library is a standard library specially designed for
 * systems without memory protection like exokernel
 * operating systems.
 *
 * @author Sergei Lodyagin <serg@kogorta.dp.ua>
 * @copyright (C) 2013 Cohors LLC
 *
 */

#ifndef _ARRAY_HEADER_
#define _ARRAY_HEADER_

#include <config.bare>
#include <iterator>
#include <cstddef>
#include <algorithm>
#include <limits>

namespace _STD {

template<class T, _STD::size_t N>
class array;

/**
 * The std::array iterator implementation.
 * It is "cycled", iterator++ at the last cell jumps to
 * start. As a result a difference between two iterators
 * count overlaps.
 *
 * FIXME errors with -fstrict-overflow (use -fwrapv?)
 *
 * @author Sergei Lodyagin
 */
template<class T, _STD::size_t N>
class _array_iterator 
#if 0
  : public _STD::iterator <
  random_access_iterator_tag,
  T,
  int32_t // <NB> it is 32-bits values to allow
  // std::div which is faster than std::ldiv
  >  
#endif
{
  // Access will generate an hw exception
  constexpr static T* not_canonical_address = 
    2 << sizeof(void*) * 8 - 1;

  friend array<T, N>;

  //! the special types to designate the begin and past-the-end
  //! construction 
  struct begin_t {};
  struct end_t {};

public:
  typedef random_access_iterator_tag iterator_category;
  typedef T value_type;
  // <NB> it is 32-bits values to allow
  // std::div which is faster than std::ldiv
  typedef int32_t difference_type;
  typedef uint32_t size_type;
  typedef T* pointer;
  typedef T& reference;
  typedef const T& const_reference;
  constexpr static size_type array_size = N;

  //! A value-initialized forward iterator
  _array_iterator() noexcept
    : _array_iterator(not_canonical_address, end_t())
  {
  }

  bool operator == (const _array_iterator b) const noexcept
  { 
    return virtual_ptr() == b.virtual_ptr();
  }
  
  bool operator != (const _array_iterator b) const noexcept
  {
    return !operator==(b);
  }


  bool operator < (const _array_iterator b) const noexcept
  {
    return *this - b < 0;
  }

  bool operator > (const _array_iterator b) const noexcept
  {
    return *this - b > 0;
  }

  bool operator <= (const _array_iterator b) const noexcept
  {
    return *this - b <= 0;
  }

  bool operator >= (const _array_iterator b) const noexcept
  {
    return *this - b >= 0;
  }

  reference operator * () noexcept
  {
    return a_begin[idx];
  }

  const_reference operator * () const noexcept
  {
    return a_begin[idx];
  }

  //! A "cycled" implementation. carry is incremented
  //! witch each overlap.
  _array_iterator& operator ++ () noexcept
  {
    if (__builtin_expect(idx++ >= N, 0))
    {
      idx = 0;
      static_assert(N < numeric_limits<uint64_t>::max()/4, 
                    "array: too big");
      carry += N;
    }
    return *this;
  }

  _array_iterator operator ++ (int) noexcept
  {
    _array_iterator copy(*this);
    ++(*this);
    return copy;
  }

  _array_iterator& operator += (difference_type n) noexcept
  {
    if (__builtin_expect((idx + n) >= N, 0))
    {
      idx += n % N;
      carry += n - n % N;
    }
    return *this;
  }

  _array_iterator operator + (difference_type n) const noexcept
  {
    _array_iterator i(*this);
    i += n;
    return i;
  }

  //! A "cycled" implementation. carry is incremented
  //! witch each overlap.
  _array_iterator& operator -- () noexcept
  {
    if (__builtin_expect(idx-- == 0, 0))
    {
      idx = N - 1;
      static_assert(N < numeric_limits<uint64_t>::max()/4, 
                    "array: too big");
      carry -= N;
    }
    return *this;
  }

  _array_iterator& operator -= (difference_type n) noexcept
  {
    return operator+=(-n);
  }

  _array_iterator operator - (difference_type n) const noexcept
  {
    _array_iterator i(*this);
    i -= n;
    return i;
  }

  difference_type operator - (const _array_iterator b) const 
  noexcept
  {
    return virtual_ptr() - b.virtual_ptr();
  }

  reference operator [] (difference_type n) noexcept
  {
    return *(*this + n);
  }

  const_reference operator [] (difference_type n) 
    const noexcept
  {
    return const_cast<_array_iterator*>(this)->operator[](n);
  }

private:
  _array_iterator(T a_ptr[], size_type the_idx) noexcept 
    : a_begin(a_ptr),
      carry(0)
  {
    static_assert(N > 0, "array: wrong specialization");
    *this += the_idx;
  }

  //! construct a begin iterator
  _array_iterator(T a_ptr[], begin_t) noexcept 
    : a_begin(a_ptr),
      idx(0),
      carry(0)
  {
  }

  //! construct a past-the-end iterator
  _array_iterator(T a_ptr[], end_t) noexcept 
    : a_begin(a_ptr),
      idx(0),
      carry(N)
  {
  }

  const T* virtual_ptr() const noexcept
  {
    return a_begin + idx + carry;
  }

  // TODO cache-line alignment
  T* a_begin;
  size_type idx;
  difference_type carry;
};

// TODO check copy-ellision
template<class T, _STD::size_t N>
inline _array_iterator<T,N> operator + 
  (typename _array_iterator<T,N>::difference_type n, 
   _array_iterator<T,N> i)
     noexcept
{
  return i + n;
}

// TODO check copy-ellision
template<class T, _STD::size_t N>
inline _array_iterator<T,N> operator - 
  (typename _array_iterator<T,N>::difference_type n, 
   _array_iterator<T,N> i) 
     noexcept
{
  return i - n;
}

/**
 * The std::array implementation.
 * It is "cycled", iterator++ at the last cell jumps to
 * start. As a result a difference between two iterators
 * count overlaps.
 *
 * @author Sergei Lodyagin
 */
template<class T, _STD::size_t N>
class array
{
  static_assert(N >= 0, "array: N is negative");
  static_assert(N < numeric_limits<int32_t>::max(),
                "array: wrong specialization");
public:
//  static_assert(is_destructible<T>, 
//               "array::value_type must be Destructible");

  typedef _array_iterator<T, N> iterator;
  typedef const iterator const_iterator;
  typedef std::reverse_iterator<iterator>
    reverse_iterator;
  typedef std::reverse_iterator<const iterator>
    const_reverse_iterator;
  typedef typename iterator::value_type value_type;
  typedef typename iterator::size_type size_type;
  typedef typename iterator::reference reference;
  typedef typename iterator::const_reference const_reference;
  typedef typename iterator::difference_type difference_type;

  //! It is public to allow the class be an aggregate (as
  //! required).
  T arr[N];

  //TODO std::out_of_range
  //reference at(size_type pos);
  //const_reference at(size_type pos) const;

  reference operator [] (size_type pos) noexcept
  {
    if (__builtin_expect(pos >= N, 0))
      pos %= N;
    return arr[pos];
  }

  // not c++-14 compatible 
  // (unable to make constexpr - use get(array) instead)
  const_reference operator [] (size_type pos) const 
    noexcept
  {
    return const_cast<array*>(this)->operator [] (pos);
  }

  reference front() noexcept
  {
    return arr[0];
  }

  constexpr const_reference front() const
  {
    return arr[0];
  }

  reference back() noexcept
  {
    return arr[N-1];
  }

  constexpr const_reference back() const
  {
    return arr[N-1];
  }

#ifdef _UNSAFE_CXX
  T* data()
  {
	 return &front();
  }

  const T* data() const
  {
	 return &front();
  }
#endif

  constexpr bool empty() const
  {
    return N == 0;
  }

  constexpr size_type size() const
  {
    return N;
  }

  constexpr size_type max_size() const
  {
    return N;
  }

  void fill(const T& value) noexcept
  {
    // TODO use cache optimization here
    for (T& e : arr) e = value;
  }

  void swap(array& other) noexcept
  {
    // TODO use cache optimization here
    for (size_type i = 0; i < N; i++)
      swap(arr[i], other.arr[i]);
  }

  // The array container implementation

  iterator begin() noexcept
  {
    return iterator(arr, typename iterator::begin_t());
  }

  const_iterator begin() const noexcept
  {
    return iterator(arr, typename iterator::begin_t());
  }

  const_iterator cbegin() const noexcept
  {
    return iterator(arr, typename iterator::begin_t());
  }

  iterator end() noexcept
  {
    return iterator(arr, typename iterator::end_t());
  }

  const_iterator end() const noexcept
  {
    return iterator(arr, typename iterator::end_t());
  }

  const_iterator cend() const noexcept
  {
    return iterator(arr, typename iterator::end_());
  }

  reverse_iterator rbegin() noexcept
  {
    return reverse_iterator(end());
  }

  const_reverse_iterator rbegin() const noexcept
  {
    return reverse_iterator(end());
  }

  const_reverse_iterator crbegin() const noexcept
  {
    return reverse_iterator(end());
  }

  reverse_iterator rend() noexcept
  {
    return reverse_iterator(begin());
  }

  const_reverse_iterator rend() const noexcept
  {
    return reverse_iterator(begin());
  }

  const_reverse_iterator crend() const noexcept
  {
    return reverse_iterator(begin());
  }

};

template< class T, std::size_t N >
bool operator==( const array<T,N>& lhs,
                 const array<T,N>& rhs )
{
  // TODO use cache optimization here
  for (typename array<T,N>::size_type i = 0; i < N; i++)
    if (lhs[i] != rhs[i])
      return false;
  return true;
}
		
template< class T, std::size_t N >
bool operator!=( const array<T,N>& lhs,
                 const array<T,N>& rhs )
{
  return !operator==(lhs, rhs);
}
		
template< class T, std::size_t N >
bool operator<( const array<T,N>& lhs,
                const array<T,N>& rhs )
{
  static_assert(N > 0, "array: wrong specialization");

  // TODO use cache optimization here
  typename array<T,N>::size_type i = 0;
  while (i < N && lhs[i] == rhs[i]) ++i;
  return i < N && lhs[i] < rhs[i];
}
		
template< class T, std::size_t N >
bool operator<=( const array<T,N>& lhs,
                 const array<T,N>& rhs )
{
  static_assert(N > 0, "array: wrong specialization");

  // TODO use cache optimization here
  typename array<T,N>::size_type i = 0;
  while (i < N && lhs[i] == rhs[i]) ++i;
  return i == N || lhs[i] < rhs[i];
}
		
template< class T, std::size_t N >
bool operator>( const array<T,N>& lhs,
                const array<T,N>& rhs )
{
  return ! operator<= (lhs, rhs);
}
		
template< class T, std::size_t N >
bool operator>=( const array<T,N>& lhs,
                 const array<T,N>& rhs )
{
  return ! operator< (lhs, rhs);
}

template< size_t I, class T, size_t N >
constexpr T& get( array<T,N>& a )
{
  static_assert(I < N,"array: the index I is out of range");
  return a[I];
}
		
template< size_t I, class T, size_t N >
constexpr T&& get( array<T,N>&& a )
{
  static_assert(I < N,"array: the index I is out of range");
  return a[I]; 
}
		
template< size_t I, class T, size_t N >
constexpr const T& get( const array<T,N>& a )
{
  static_assert(I < N,"array: the index I is out of range");
  return a[I]; 
}

//! The for_each specialization for array
template<class UnaryFunction, class T, size_t N>
UnaryFunction for_each
  ( _array_iterator<T, N> first, 
    _array_iterator<T, N> last, 
    UnaryFunction f )
{
  // TODO check assembly 
  if (__builtin_expect(first.a_begin != last.a_begin, 0)
      || __builtin_expect
           (first.virtual_ptr() < first.a_begin, 0)
      || __builtin_expect
           (first.virtual_ptr() > first.a_begin + N, 0)
      || __builtin_expect
           (last.virtual_ptr() < last.a_begin, 0)
      || __builtin_expect
           (last.virtual_ptr() > last.a_begin + N, 0))
    return std::move(f);
  

  for ( auto p = first.virtual_ptr();
        p < last.virtual_ptr();
        p++ )
    f(*p);

  return std::move(f);
}

}

#endif
