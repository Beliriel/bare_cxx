// -*-coding: mule-utf-8-unix; fill-column: 58 -*-
/** 
 * @file
 *
 * This file is a part of Bare C++ library. Bare C++ library is a standard
 * library specially designed for systems without memory protection like
 * exokernel operating systems.
 *
 * @author Sergei Lodyagin <serg@kogorta.dp.ua>
 * @copyright (C) 2013 Cohors LLC
 *
 */

#ifndef _ARRAY_HEADER_
#define _ARRAY_HEADER_

//#include <type_traits>

namespace std {

/**
 * The std::array implementation.
 * It is "cycled", iterator++ at the last cell jumps to
 * start. As a result a difference between two iterators
 * count overlaps.
 *
 * @author Sergei Lodyagin
 */
template<class T, std::size_t N>
class array
{
  T arr[N];
  typedef size_t index_type;
  typedef int8_t carry_type;

  static_assert(N >= 0, "array: N is negative");
public:
  typedef T value_type;
//  static_assert(is_destructible<T>, 
//               "array::value_type must be Destructible");

  typedef T& reference;
  typedef const T& const_reference;
  typedef ptrdiff_t difference_type;
  typedef size_t size_type;

  class iterator
  {
    // Access will generate an hw exception
    constexpr static not_canonical_address = 
      2 << sizeof(void*) * 8 - 1;
  public:
    //! A value-initialized forward iterator
    iterator() noexcept
      : iterator(not_canonical_address, N)
    {
    }

    bool operator == (const iterator& b) const noexcept
    { 
      return virtual_ptr() == b.virtual_ptr();
    }
  
    bool operator != (const iterator& b) const noexcept
    {
      return !operator==(b);
    }

    bool operator < (const iterator& b) const noexcept
    {
      return *this - b < 0;
    }

    bool operator > (const iterator& b) const noexcept
    {
      return *this - b > 0;
    }

    bool operator <= (const iterator& b) const noexcept
    {
      return *this - b <= 0;
    }

    bool operator >= (const iterator& b) const noexcept
    {
      return *this - b >= 0;
    }

    reference operator * () noexcept
    {
      return *ptr;
    }

    const_reference operator * () const noexcept
    {
      return *ptr;
    }

    //! A "cycled" implementation. carry is incremented
    //! witch each overlap.
    iterator& operator ++ () noexcept
    {
      if (__builtin_expect(ptr++ >= a_last, 0))
      {
        ptr = a_begin;
        static_assert(N < UINT64MAX/4, "array: too big");
        carry += N;
      }
      return *this;
    }

    //! A "cycled" implementation. carry is incremented
    //! witch each overlap.
    iterator operator ++ (int) noexcept
    {
      iterator copy(*this);
      ++(*this);
      return copy;
    }

#if 0
    iterator& operator += (ptrdiff_t n) noexcept
    {
      T* const ptr2 = ptr + n;
      const bool underflow = ptr2 < a_begin;
      if (__builtin_expect(ptr2 > a_last || underflow, 0))
      {
        if (underflow) {
          // n < 0
          ptr += n 
      }
      return *this;
    }
#endif

    //! A "cycled" implementation. carry is incremented
    //! witch each overlap.
    iterator& operator -- () noexcept
    {
      if (__builtin_expect(ptr-- <= a_begin, 0))
      {
        ptr = a_last;
        static_assert(N < UINT64MAX/4, "array: too big");
        carry -= N;
      }
      return *this;
    }

    //! A "cycled" implementation. carry is incremented
    //! witch each overlap.
    iterator operator -- (int) noexcept
    {
      iterator copy(*this);
      --(*this);
      return copy;
    }

    difference_type operator - (const iterator& b) const 
      noexcept
    {
      return virtual_ptr() - b.virtual_ptr();
    }

  private:
    //! construct a past-the-end iterator
    explicit iterator(T a_ptr[], size_t idx) noexcept 
      : a_begin(a_ptr),
        a_last(a_ptr + N - 1),
        ptr(a_ptr),
        carry(0)
    {
      static_assert(N > 0, "array: wrong specialization");
      *this += idx;
    }

    const T* virtual_ptr() const noexcept
    {
      return ptr + carry;
    }

    // TODO cache-line alignment
    T* a_begin;
    T* a_last;
    T* ptr;
    int64_t carry;
  };

  typedef const iterator const_iterator;
};

}

#endif
